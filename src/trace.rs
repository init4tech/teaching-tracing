//! The [`init_tracing`] function sets up tracing for the application.
//! [`init_otel_provider`] is also interesting :)

use opentelemetry::{KeyValue, trace::TracerProvider};
use opentelemetry_sdk::{Resource, trace::SdkTracerProvider};
use opentelemetry_semantic_conventions::{
    SCHEMA_URL,
    attribute::{DEPLOYMENT_ENVIRONMENT_NAME, SERVICE_NAME, SERVICE_VERSION},
};
use tracing_subscriber::{
    Layer, filter::EnvFilter, fmt, layer::SubscriberExt, util::SubscriberInitExt,
};

const OTEL_FILTER: &str = "OTEL_FILTER";

/// This is the basic tracing initialization function. It sets up the following:
///
/// - A [`tracing`] subscriber
/// - A [`fmt::Layer`] for sending trace info to stdout.
/// - An [`opentelemetry_sdk`] provider and exporter.
///
/// ## [`tracing`] vs [`opentelemetry`]
///
/// In a nutshell, [`tracing`] is a Rust-specific crate for instrumenting code.
/// [`opentelemetry`] is a broad standard for instrumentation and telemetry. As
/// engineers, **we tend to write code with [`tracing`] and then use
/// opentelemetry ecosystem tooling to export, inspect, and analyze the data we
/// generate.**
///
/// The `tracing` crate provides structured, event-based tracing for Rust. It
/// has broad adoption in the Rust ecosystem, and is the de facto standard for
/// application-level tracing in Rust. It provides the `Span` and `Event` types,
/// as well as macros for instrumenting code with spans and events.
///
/// Opentelemetry (OTEL) is a broader standard for telemetry data, including
/// distributed tracing, metrics, and logging. It is vendor- and
/// language-neutral. Its goal is to provide common standards for telemetry
/// data across different systems and platforms.
///
/// The [`tracing_opentelemetry`] crate bridges the two, allowing spans and
/// events generated by [`tracing`] to be translated to OTEL spans and events,
/// and exported via OTLP to OTEL-compatible backends.
///
/// ## [`tracing`] vs [`tracing_subscriber`]
///
/// The [`tracing`] crate provides the core types and macros for instrumenting
/// code with spans and events. However, it does not provide any way to
/// collect, filter, or export that data. This is where the
/// [`tracing_subscriber`] crate comes in. It provides a framework for
/// externalizing trace data, as well as some standard layers for exporting
/// trace data to various backends, like the [`fmt::Layer`] for printing trace
/// data to `stdout`.
///
/// Subscribers can be composed of multiple layers, allowing trace data to be
/// exported to multiple backends simultaneously. In this example, we export to
/// both `stdout` via a [`fmt::Layer`] and an OTLP endpoint. In addition, the
/// [`Filter`] trait allows fine-grained control over which spans and events
/// are recorded and exported to each specific subscriber [`Layer`].
///
/// Libraries should NOT set up subscribers or exporters. This is the
/// responsibility of the binary developer. Libraries should only use the
/// [`tracing`] crate to instrument their code, and allow the binary developer
/// to set up the subscriber(s) they want.
///
/// ## The Otel Provider
///
/// The [`SdkTracerProvider`] is a factory for creating tracers, which manage
/// OTEL spans and trace information. Note that these are distinct from
/// [`tracing::Span`]s, although conceptually related. The provider is the root
/// of the [`opentelemetry::trace::Tracer`] hierarchy, and is a drop-guard for
/// OTEL tracing setup and the OTLP exporter. Because dropping it will shut
/// down the OTEL tracing system, this should be held for the lifetime of the
/// program.  Many bins will want to store this in a [`std::sync::LazyLock`]
/// like so:
///
/// ```rust
/// use std::sync::LazyLock;
/// use metrics_tracing_example::init_tracing;
/// use opentelemetry_sdk::trace::SdkTracerProvider;
///
/// static OTEL_PROVIDER: LazyLock<SdkTracerProvider> = LazyLock::new(init_tracing);
/// ```
///
/// The [`SdkTracerProvider`] configures itself automatically using the
/// following env vars:
///
/// - `OTEL_EXPORTER_OTLP_ENDPOINT` - The endpoint to send spans to.
/// - `OTEL_TRACES_EXPORTER` -  The exporter to use. Typically `otlp`
/// - `OTEL_EXPORTER_OTLP_PROTOCOL` - The protocol to use. Typically `http/
///   protobuf` or `grpc`.
///
/// Additional configuration can be found in the [`opentelemetry_sdk`] crate.
///
/// ## Warning
///
/// The exporter instantiation will fail if invoked outside of a `tokio`
/// runtime.
///
/// [`Filter`]: tracing_subscriber::layer::Filter
pub fn init_tracing() -> SdkTracerProvider {
    if tokio::runtime::Handle::try_current().is_err() {
        panic!(
            "init_tracing must be called from within a tokio runtime. This is a limitation of the opentelemetry exporter."
        );
    }

    let registry = tracing_subscriber::registry();

    let env_filter = EnvFilter::from_default_env();

    // load otel from env, if the var is present, otherwise just use fmt
    let otel_filter = if std::env::var(OTEL_FILTER)
        .as_ref()
        .map(String::len)
        .unwrap_or_default()
        > 0
    {
        EnvFilter::from_env(OTEL_FILTER)
    } else {
        env_filter.clone()
    };

    let otel_provider = init_otel_provider();
    let tracer = otel_provider.tracer("tracing-otel-subscriber");

    let otel_layer = tracing_opentelemetry::layer()
        .with_tracer(tracer)
        .with_filter(otel_filter);
    let fmt_layer = fmt::layer().with_filter(env_filter);

    registry.with(fmt_layer).with(otel_layer).init();

    otel_provider
}

/// Instantiate a new Otel provider. This is the simplest possible setup.
///
/// The OTEL system in rust is composed of two main parts
/// - The provider, which manages tracers and spans in the program.
/// - The exporter, which sends spans to an external system.
///
/// In this example, the provider is configured to export spans via OTLP over
/// HTTP. The endpoint is configured via the `OTEL_EXPORTER_OTLP_ENDPOINT` env
/// var. This is part of a set of [standard env vars] that are respected by the
/// [`SpanExporter`] in the [`opentelemetry_otlp`] crate.
///
/// The [`opentelemetry_otlp`] crate also provides a [`LogExporter`] and a
/// `MetricExporter` (with the "metrics" feature), however, this example only
/// uses the [`SpanExporter`].
///
/// For additional provider configuration, see the [`opentelemetry_sdk`] crate.
///
/// [`LogExporter`]: opentelemetry_otlp::LogExporter
/// [`MetricExporter`]: opentelemetry_otlp::MetricExporter
/// [`SpanExporter`]: opentelemetry_otlp::SpanExporter
/// [standard env vars]: https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/
fn init_otel_provider() -> SdkTracerProvider {
    let exporter = opentelemetry_otlp::SpanExporter::builder()
        .with_http()
        .build()
        .unwrap();

    SdkTracerProvider::builder()
        // Customize sampling strategy
        // If export trace to AWS X-Ray, you can use XrayIdGenerator
        .with_resource(create_otel_resource())
        .with_batch_exporter(exporter)
        .build()
}

/// This creates a [`Resource`].
///
/// Otel resources describe the application being instrumented. They're used by
/// collectors to organize and label telemetry data.
///
/// The resource should be fairly static, so we just hardcode some values here.
fn create_otel_resource() -> Resource {
    Resource::builder()
        .with_schema_url(
            vec![
                KeyValue::new(SERVICE_NAME, env!("CARGO_PKG_NAME")),
                KeyValue::new(SERVICE_VERSION, env!("CARGO_PKG_VERSION")),
                KeyValue::new(DEPLOYMENT_ENVIRONMENT_NAME, "production"),
            ],
            SCHEMA_URL,
        )
        .build()
}
